<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Opensource on Kubermates</title><link>https://kubermates.org/tags/opensource/</link><description>Recent content in Opensource on Kubermates</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 02 Sep 2024 11:41:41 +0000</lastBuildDate><atom:link href="https://kubermates.org/tags/opensource/index.xml" rel="self" type="application/rss+xml"/><item><title>Autoscaling in Kubernetes: KEDA, Karpenter, and Native Autoscalers</title><link>https://kubermates.org/blog/autoscaling-in-kubernetes-keda-karpenter-and-native-autoscalers-1gpo/</link><pubDate>Mon, 02 Sep 2024 11:41:41 +0000</pubDate><guid>https://kubermates.org/blog/autoscaling-in-kubernetes-keda-karpenter-and-native-autoscalers-1gpo/</guid><description>&lt;p>Autoscaling is a critical component of any robust Kubernetes environment, ensuring your applications and infrastructure can dynamically adjust to meet demand. In this guide, we&amp;rsquo;ll explore three powerful autoscaling tools: &lt;strong>KEDA&lt;/strong> for event-driven pod autoscaling, &lt;strong>Karpenter&lt;/strong> for dynamic node scaling, and Kubernetes&amp;rsquo; native autoscalers (HPA and VPA). We&amp;rsquo;ll dive into how to use them effectively, with plenty of examples to get you started. 🚀&lt;/p>
&lt;h2 id="introduction-to-keda-">Introduction to KEDA 🚀&lt;/h2>
&lt;p>KEDA (Kubernetes-based Event Driven Autoscaling) allows you to scale applications based on custom event metrics, not just CPU or memory usage. It’s ideal for scenarios where workloads are triggered by external events, such as message queues, databases, or HTTP requests. Whether you&amp;rsquo;re processing incoming orders, reacting to sensor data, or scaling based on custom Prometheus metrics, KEDA has you covered! 💥&lt;/p></description></item><item><title>🚀 Building a Kubernetes Operator with an NGINX CRD</title><link>https://kubermates.org/blog/building-a-kubernetes-operator-with-an-nginx-crd-3lil/</link><pubDate>Thu, 29 Aug 2024 08:25:36 +0000</pubDate><guid>https://kubermates.org/blog/building-a-kubernetes-operator-with-an-nginx-crd-3lil/</guid><description>&lt;p>Kubernetes is a powerful platform that automates the deployment, scaling, and management of containerized applications. One of the coolest features of Kubernetes is its ability to be extended with &lt;strong>Custom Resource Definitions (CRDs)&lt;/strong> and &lt;strong>Operators&lt;/strong>. In this guide, we&amp;rsquo;ll build a simple Kubernetes operator using an NGINX CRD to manage NGINX instances in your cluster.&lt;/p>
&lt;h3 id="-understanding-kubernetes-controllers-operators-and-crds">🤖 Understanding Kubernetes Controllers, Operators, and CRDs&lt;/h3>
&lt;h4 id="what-is-a-kubernetes-controller">What is a Kubernetes Controller?&lt;/h4>
&lt;p>A Kubernetes controller is like a robot 🤖 that continuously monitors your cluster. It checks whether the actual state of the resources matches the desired state (what you want) and makes adjustments to align them.&lt;/p></description></item><item><title>🎨 Hacking the Helm Operator with Flux: Creating Self-Installable Services for Easier App Deployment</title><link>https://kubermates.org/blog/hacking-the-helm-operator-with-flux-creating-self-installable-services-for-easier-app-deployment-5a8l/</link><pubDate>Wed, 28 Aug 2024 08:01:26 +0000</pubDate><guid>https://kubermates.org/blog/hacking-the-helm-operator-with-flux-creating-self-installable-services-for-easier-app-deployment-5a8l/</guid><description>&lt;p>Managing applications in Kubernetes can be tricky, but with tools like Helm, operators, and Flux, you can make the process smoother and even fun! In this guide, we&amp;rsquo;ll walk you through how to hack the Helm Operator using the Operator SDK and Flux to create powerful, self-installable services that make deploying apps like NGINX, Apache Tomcat, and even Redis a breeze. 🌬️&lt;/p>
&lt;p>By the end, you&amp;rsquo;ll have your very own GitOps-powered system, making deployments as simple as pushing to a Git repository. Let&amp;rsquo;s dive in!&lt;/p></description></item><item><title>How to Make Your Docker Images Go on a Diet 🏊‍♂️</title><link>https://kubermates.org/blog/how-to-make-your-docker-images-go-on-a-diet-88l/</link><pubDate>Wed, 21 Aug 2024 07:50:27 +0000</pubDate><guid>https://kubermates.org/blog/how-to-make-your-docker-images-go-on-a-diet-88l/</guid><description>&lt;p>Hey there, Docker enthusiast! 🌟 Are your Docker images feeling a little bloated lately? Don&amp;rsquo;t worry, you&amp;rsquo;re not alone. As our applications grow, so do our Docker images, but with a few nifty tricks, you can slim them down and keep everything running smooth as butter. 🧈 In this guide, we&amp;rsquo;ll explore how to optimize your Docker images using Alpine, Distroless, Scratch images, and multi-stage builds. Let&amp;rsquo;s dive in! 🏊‍♂️&lt;/p></description></item><item><title>A quick navigation through Service Mesh in Kubernetes 👀</title><link>https://kubermates.org/blog/a-quick-navigation-through-service-mesh-in-kubernetes-5dea/</link><pubDate>Tue, 20 Aug 2024 10:52:45 +0000</pubDate><guid>https://kubermates.org/blog/a-quick-navigation-through-service-mesh-in-kubernetes-5dea/</guid><description>&lt;p>If you&amp;rsquo;re working with Kubernetes, you know that managing communication between microservices can get complicated as your application grows. Enter &lt;strong>Linkerd&lt;/strong>, a powerful yet user-friendly service mesh that simplifies this process by handling traffic management, security, and observability for your microservices. In this article, we&amp;rsquo;ll walk you through what Linkerd is, how to set it up, and how to use it to manage your services, including examples of Blue-Green and Canary deployments. We’ll also compare Linkerd with Istio, another popular service mesh, and provide references to official documentation to help you along the way.&lt;/p></description></item><item><title>🚀 Kubernetes RBAC and Role Aggregation Made Easy</title><link>https://kubermates.org/blog/kubernetes-rbac-and-role-aggregation-made-easy-3j4o/</link><pubDate>Mon, 19 Aug 2024 21:03:46 +0000</pubDate><guid>https://kubermates.org/blog/kubernetes-rbac-and-role-aggregation-made-easy-3j4o/</guid><description>&lt;h2 id="what-is-kubernetes-rbac-">What is Kubernetes RBAC? 🤔&lt;/h2>
&lt;p>Kubernetes, the platform that helps you automate, scale, and manage your containerized applications, comes with a cool feature called &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">Role-Based Access Control (RBAC)&lt;/a>. Think of RBAC as a gatekeeper that controls who can do what within your Kubernetes cluster. It’s super important because it ensures that everyone and everything (like users, applications, and services) only have the permissions they need—nothing more, nothing less.&lt;/p>
&lt;h2 id="the-four-pillars-of-kubernetes-rbac-">The Four Pillars of Kubernetes RBAC 🏛️&lt;/h2>
&lt;p>Kubernetes RBAC revolves around four main building blocks:&lt;/p></description></item><item><title>How to Test the Latest Kubernetes Changes in Version 1.31 "Elli"</title><link>https://kubermates.org/blog/how-to-test-the-latest-kubernetes-changes-in-version-131-elli-39ec/</link><pubDate>Wed, 14 Aug 2024 21:38:00 +0000</pubDate><guid>https://kubermates.org/blog/how-to-test-the-latest-kubernetes-changes-in-version-131-elli-39ec/</guid><description>&lt;p>Testing Kubernetes 1.31 &amp;ldquo;Elli&amp;rdquo; involves setting up a dedicated environment, verifying new features, validating API changes, running automated tests, and closely monitoring your cluster. Here’s a detailed guide with examples for each step.&lt;/p>
&lt;h2 id="1-set-up-a-testing-environment">1. Set Up a Testing Environment&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Create a Kubernetes Cluster&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Example&lt;/strong>: Use Minikube to create a local cluster. Run:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">minikube start --kubernetes-version&lt;span class="o">=&lt;/span>v1.31.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>This command sets up a Kubernetes 1.31 cluster locally, allowing you to test the new features and changes in a controlled environment.&lt;/li>
&lt;li>&lt;strong>Cloud-Based Testing&lt;/strong>: For cloud environments, use a tool like &lt;code>eksctl&lt;/code> for Amazon EKS:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">eksctl create cluster --version 1.31 --name test-cluster
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>This command creates an Amazon EKS cluster with Kubernetes 1.31, suitable for more extensive testing scenarios.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Isolate the Environment&lt;/strong>:&lt;/p></description></item></channel></rss>